import hashlib  # Used to specify the hashing algorithm (here SHA1)
from itsdangerous import URLSafeTimedSerializer  # A basic class for signing and verifying data with built-in timestamp and URL-safe encoding
from itsdangerous.exc import BadTimeSignature  # Exception that occurs when signature or timestamp verification fails
from flask.sessions import TaggedJSONSerializer  # Flask's default serializer for session data (tagged JSON)


# This function imitates the signing and verification logic that Flask uses for its session cookies.
# It is a simplified version of the SecureCookieSessionInterface interface from Flask.
def flask_cookie(secret_key, cookie_str, operation):
    # "Salt" is an additional string used during signing.
    # This is the default salt for Flask sessions.
    salt = 'cookie-session'

    # We use the standard Flask serializer for JSON session data.
    # It adds tags to JSON so that itsdangerous knows that it is JSON.
    serializer = TaggedJSONSerializer()

    # Parameters for a signer using URLSafeTimedSerializer.
    signer_kwargs = {
        'key_derivation': 'hmac',  # Please note that HMAC is used to generate the signer's key.
        'digest_method': hashlib.sha1  # Please note that the SHA1 algorithm is used for HMAC.
        # NOTE: This differs from HS256 (HMAC-SHA256), which you saw on jwt.io.
        # It is likely that the server actually uses SHA1, or this script found the key specifically for the SHA1 signature.
    }

    # Create an instance of URLSafeTimedSerializer.
    # secret_key: Secret key for signing.
    # salt: Additional salt.
    # serializer: An object for serializing/deserializing data (JSON).
    # signer_kwargs: Additional parameters for the signer (here, the choice of hashing algorithm).
    s = URLSafeTimedSerializer(secret_key, salt=salt, serializer=serializer, signer_kwargs=signer_kwargs)

    if operation == "decode":
        # If the operation is "decode":
        # s.loads(cookie_str) decrypts base64, verifies the signature (using secret_key, salt, serializer, signer_kwargs),
        # checks the timestamp (whether the cookie has expired), deserializes the data (JSON), and returns it.
        # If the signature or timestamp is invalid, a BadTimeSignature exception is thrown.
        return s.loads(cookie_str)
    else:  # operation == "encode"
        # If operation is "encode":
        # s.dumps(cookie_str) serialises the input data (JSON), adds a timestamp and salt,
        # calculates the signature using secret_key, salt, and signer_kwargs settings,
        # and encodes everything into a URL-safe base64 format with “.” separators.
        return s.dumps(cookie_str)

# --- End of flask_cookie function ---
